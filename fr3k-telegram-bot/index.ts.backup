#!/usr/bin/env bun
/**
 * PAI Telegram Bot - Main orchestrator
 *
 * Coordinates communication agent and voice agent.
 * Processes messages from queue without blocking.
 */

import { Bot } from "grammy";
import { spawn } from "bun";
import { unlinkSync } from "fs";
import { tracer } from "./observability/tracer.js";
import { getWorkflowStore } from "./observability/workflow-store.js";
import { getMessageLineage } from "./observability/message-lineage.js";
import { getInstanceTracker } from "./observability/instance-tracker.js";
import { validatePAIResponse } from "./response-validation.js";
import { antiRepetitionSystem } from "./anti-repetition.js";
import { handleDispatcherTask } from "./agents/dispatcher-agent.js";

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || "";
const ALLOWED_USER_ID = process.env.TELEGRAM_USER_ID || "";
const SESSION_FILE = process.env.SESSION_FILE || "/tmp/pai-telegram-sessions.json";
const MESSAGE_QUEUE_PATH = "/tmp/pai-message-queue.json";
const NEW_MESSAGE_FLAG = "/tmp/pai-new-message.flag";

// State
let sessions = new Map<string, string>();
let isProcessing = false;

// Response validation monitoring
const responseValidationStats = {
  totalResponses: 0,
  validResponses: 0,
  invalidResponses: 0,
  lastValidationTime: 0
};

// Initialize bot for sending responses
const bot = new Bot(BOT_TOKEN);

// Load sessions
async function loadSessions() {
  try {
    const data = await Bun.readableStreamToText(Bun.file(SESSION_FILE).stream());
    const obj = JSON.parse(data);
    sessions = new Map(Object.entries(obj));
  } catch {
    sessions = new Map();
  }
}

// Save sessions
async function saveSessions() {
  await Bun.write(SESSION_FILE, JSON.stringify(Object.fromEntries(sessions)));
}

// Async voice notification (via voice agent)
async function sendVoiceNotification(message: string, phase: "work" | "complete" | "checkin" | "error" | "iteration" = "work") {
  try {
    await fetch("http://localhost:8888/notify", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ message, phase, priority: 7 })
    });
  } catch (error) {
    console.error("‚ùå Voice notification failed:", error);
  }
}

// ============================================================================
// MESSAGE DELIVERY VERIFICATION SYSTEM
// ============================================================================

interface DeliveryResult {
  success: boolean;
  messageId?: number;
  error?: string;
  retryCount: number;
}

// Track consecutive failures per user
const consecutiveFailures = new Map<string, number>();

// Exponential backoff delay
function getBackoffDelay(attempt: number): number {
  return Math.min(1000 * Math.pow(2, attempt), 10000); // Max 10 seconds
}

// Verify message delivery with retry logic
async function verifyMessageDelivery(
  chatId: number,
  text: string,
  userId: string,
  maxRetries: number = 3
): Promise<DeliveryResult> {
  let attempt = 0;

  while (attempt <= maxRetries) {
    try {
      console.log(`üì§ Sending message (attempt ${attempt + 1}/${maxRetries + 1}) to user ${userId}`);

      // Send the message
      const response = await bot.api.sendMessage(chatId, text);

      // For Telegram, a successful send returns the message ID
      if (response && response.message_id) {
        console.log(`‚úÖ Message delivered successfully with ID: ${response.message_id}`);

        // Reset consecutive failures on success
        consecutiveFailures.set(userId, 0);
        updateDeliveryMetrics(userId, true);

        return {
          success: true,
          messageId: response.message_id,
          retryCount: attempt
        };
      }
    } catch (error) {
      attempt++;
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`‚ùå Message delivery failed (attempt ${attempt}):`, errorMsg);

      if (attempt <= maxRetries) {
        const delay = getBackoffDelay(attempt - 1);
        console.log(`‚è≥ Retrying in ${delay}ms...`);

        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  // All attempts failed
  const currentFailures = (consecutiveFailures.get(userId) || 0) + 1;
  consecutiveFailures.set(userId, currentFailures);
  updateDeliveryMetrics(userId, false);

  console.error(`üí• Message delivery failed after ${maxRetries + 1} attempts to user ${userId}`);
  console.error(`üìä Consecutive failures for user ${userId}: ${currentFailures}`);
  console.error(`üìà Total metrics for user ${userId}:`, deliveryMetrics.get(userId));

  // Send voice notification for 3 consecutive failures
  if (currentFailures >= 3) {
    await sendVoiceNotification(
      `Critical: Telegram delivery failed 3+ times for user ${userId}`,
      "error"
    );
  }

  return {
    success: false,
    error: `Failed after ${maxRetries + 1} attempts`,
    retryCount: maxRetries
  };
}

// ============================================================================
// OBSERVABILITY: Message interface with trace context
// ============================================================================

interface QueuedMessage {
  id: string;
  text: string;
  userId: string;
  timestamp: number;
  traceContext?: {
    traceParent: string;
    traceState?: string;
    traceId: string;
    spanId: string;
  };
  username?: string;
  chatId?: string;
  messageId?: number;
}

// Read message from queue (LIFO - newest first for responsiveness)
async function getNextMessage(): Promise<QueuedMessage | null> {
  try {
    const data = await Bun.readableStreamToText(Bun.file(MESSAGE_QUEUE_PATH).stream());
    const queue = JSON.parse(data) || [];

    if (queue.length === 0) return null;

    // Get LAST message (LIFO - newest first)
    const msg = queue.pop();

    // Save updated queue
    await Bun.write(MESSAGE_QUEUE_PATH, JSON.stringify(queue, null, 2));

    return msg;
  } catch {
    return null;
  }
}

// ============================================================================
// OBSERVABILITY: PAI Algorithm Phase Tracing
// ============================================================================

interface PAIProcessingResult {
  response: string;
  sessionId?: string;
  phases: {
    name: string;
    duration: number;
    subagents?: string[];
    tools?: string[];
  }[];
}

// Call PAI (Claude Code) with timeout and full observability tracing
async function callPAI(prompt: string, userId: string, traceContext?: any): Promise<PAIProcessingResult> {
  // ========================================================================
  // OBSERVE PHASE SPAN
  // ========================================================================
  const observeSpan = tracer.span.paiPhase("OBSERVE", {
    "pai.prompt.length": prompt.length,
    "pai.user.id": userId,
  });

  const sessionId = sessions.get(userId);
  const claudePath = "/home/fr3k/.nvm/versions/node/v24.13.0/bin/claude";

  // Prefix with [TELEGRAM] marker so FormatReminder knows to use natural conversation mode
  const telegramPrompt = `[TELEGRAM] ${prompt}`;

  observeSpan.setAttribute("pai.session.resumed", !!sessionId);
  tracer.span.success(observeSpan);
  observeSpan.end();

  // ========================================================================
  // THINK PHASE SPAN
  // ========================================================================
  const thinkSpan = tracer.span.paiPhase("THINK", {
    "pai.capabilities.assessing": true,
  });

  // Build args - prompt goes via stdin, not as argument
  const args = ["-p", "--output-format", "json"];

  if (sessionId) {
    args.push("--resume", sessionId);
  }

  thinkSpan.setAttribute("pai.args", JSON.stringify(args));
  tracer.span.success(thinkSpan);
  thinkSpan.end();

  // ========================================================================
  // PLAN PHASE SPAN
  // ========================================================================
  const planSpan = tracer.span.paiPhase("PLAN", {
    "pai.timeout.configured": "300000",
  });

  // Extended timeout for complex PAI responses (5 minutes)
  const TIMEOUT_MS = 300000; // 5 minutes instead of 60s

  // Progress notification timer - EVERY 2 MINUTES
  const PROGRESS_INTERVAL_MS = 120000; // 2 minutes
  let progressCounter = 0;
  const progressTimer = setInterval(() => {
    progressCounter++;
    const minutesElapsed = progressCounter * 2;

    console.log(`‚è∞ Sending progress update: ${minutesElapsed} minutes elapsed`);

    // Send voice notification
    sendVoiceNotification(
      `Still working on your request... ${minutesElapsed} minutes so far`,
      "work"
    );

    // Send Telegram progress update
    verifyMessageDelivery(
      parseInt(ALLOWED_USER_ID),
      `‚è≥ Still working...\n\nüïê ${minutesElapsed} minutes elapsed\nüîÑ Task in progress\n\nWill send full response when complete.`,
      "progress"
    );

  }, PROGRESS_INTERVAL_MS);

  planSpan.setAttribute("pai.progress.timer.configured", PROGRESS_INTERVAL_MS.toString());
  tracer.span.success(planSpan);
  planSpan.end();

  // ========================================================================
  // BUILD PHASE SPAN - Execute the PAI call
  // ========================================================================
  const buildSpan = tracer.span.paiPhase("BUILD", {
    "pai.claude.path": claudePath,
  });

  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error("PAI call timeout after 5 minutes")), TIMEOUT_MS);
  });

  const paiPromise = (async () => {
    console.log(`üìû Calling PAI with prompt: ${prompt.substring(0, 40)}...`);

    // Use shell to pipe the prompt to claude
    const shellScript = `
      echo ${JSON.stringify(telegramPrompt)} | ${claudePath} ${args.join(' ')}
    `;

    // Create tool span for the actual CLI invocation
    const toolSpan = tracer.span.tool("claude.cli", {
      "cli.command": claudePath,
      "cli.args": JSON.stringify(args),
      "cli.input.length": telegramPrompt.length,
    });

    const proc = Bun.spawn({
      cmd: ["/bin/bash", "-c", shellScript],
      stdout: "pipe",
      stderr: "pipe",
      env: {
        ...process.env,
        PATH: `${process.env.PATH}:/home/fr3k/.nvm/versions/node/v24.13.0/bin`,
        TELEGRAM_BOT_REQUEST: '1',
        // Propagate trace context to PAI subprocess
        ...(traceContext?.traceParent ? { [`traceparent=${traceContext.traceParent}`]: '1' } : {}),
      }
    });

    const output = await new Response(proc.stdout).text();

    toolSpan.setAttribute("cli.output.length", output?.length || 0);

    if (!output || output.length === 0) {
      tracer.span.error(toolSpan, new Error("Empty response from PAI"));
      toolSpan.end();
      throw new Error("Empty response from PAI");
    }

    const result = JSON.parse(output);

    console.log(`‚úì PAI response received: ${result.result?.substring(0, 50) || "No response"}...`);

    toolSpan.setAttribute("cli.session.id", result.session_id || "none");
    tracer.span.success(toolSpan);
    toolSpan.end();

    clearInterval(progressTimer); // Cancel progress notifications

    return {
      response: result.result || "No response from PAI",
      sessionId: result.session_id,
      phases: [
        { name: "OBSERVE", duration: Date.now() - (observeSpan.startTime as number) },
        { name: "THINK", duration: Date.now() - (thinkSpan.startTime as number) },
        { name: "PLAN", duration: Date.now() - (planSpan.startTime as number) },
        { name: "BUILD", duration: Date.now() - (buildSpan.startTime as number) },
      ],
    };
  })();

  try {
    const result = await Promise.race([paiPromise, timeoutPromise]);
    tracer.span.success(buildSpan);
    buildSpan.end();

    // ========================================================================
    // EXECUTE PHASE SPAN
    // ========================================================================
    const executeSpan = tracer.span.paiPhase("EXECUTE", {
      "pai.response.length": result.response.length,
    });

    if (result.sessionId) {
      sessions.set(userId, result.sessionId);
      await saveSessions();
      executeSpan.setAttribute("pai.session.saved", result.sessionId);
    }

    tracer.span.success(executeSpan);
    executeSpan.end();

    // ========================================================================
    // VERIFY PHASE SPAN
    // ========================================================================
    const verifySpan = tracer.span.paiPhase("VERIFY", {
      "pai.response.valid": result.response.length > 0,
    });

    tracer.span.success(verifySpan);
    verifySpan.end();

    // ========================================================================
    // LEARN PHASE SPAN
    // ========================================================================
    const learnSpan = tracer.span.paiPhase("LEARN", {
      "pai.session.count": sessions.size,
    });

    tracer.span.success(learnSpan);
    learnSpan.end();

    return result;
  } catch (error) {
    tracer.span.error(buildSpan, error as Error);
    buildSpan.end();
    clearTimeout(progressTimer); // Clean up timer
    console.error("‚ùå PAI call failed:", error);
    return {
      response: `Sorry, I'm having trouble connecting right now. ${error instanceof Error ? error.message : ''}`,
      phases: [],
    };
  }
}

// Process messages from queue
async function processMessageQueue() {
  if (isProcessing) return;

  const msg = await getNextMessage();
  if (!msg) return;

  // ========================================================================
  // OBSERVABILITY: Multi-instance race detection
  // ========================================================================
  const tracker = getInstanceTracker();
  const traceId = msg.traceContext?.traceId || `trace-${Date.now()}`;

  // Check if another instance is already processing this message/trace
  if (!tracker.tryAcquireLock(msg.id, traceId)) {
    console.log(`‚ö†Ô∏è Message ${msg.id} already being processed by another instance`);
    return;
  }

  isProcessing = true;
  console.log(`üîÑ Processing: ${msg.text.substring(0, 50)}...`);

  // ========================================================================
  // OBSERVABILITY: Start workflow execution tracking
  // ========================================================================
  const workflowStore = getWorkflowStore();
  const lineageStore = getMessageLineage();

  // Add user message to lineage
  lineageStore.addUserMessage(
    msg.id,
    msg.text,
    msg.userId,
    traceId,
    {
      username: msg.username,
      chatId: msg.chatId,
    }
  );

  // Create processing span with trace context propagation
  const processSpan = tracer.span.telegram({
    "telegram.message.id": msg.id,
    "telegram.message.text": msg.text,
    "telegram.user.id": msg.userId,
    "telegram.processing.started": new Date().toISOString(),
  });

  // If we have trace context from the communication agent, link it
  if (msg.traceContext) {
    processSpan.setAttribute("trace.parent_id", msg.traceContext.traceId);
  }

  // Start workflow execution
  const execution = workflowStore.startExecution(
    traceId,
    processSpan.spanContext().spanId,
    {
      id: msg.id,
      text: msg.text,
      userId: msg.userId,
      username: msg.username,
      chatId: msg.chatId,
      messageId: msg.messageId,
      timestamp: Date.now(),
    },
    {
      instanceId: tracker.getMyInstanceId(),
      hostname: process.env.HOSTNAME || "localhost",
      processedBy: "main-bot",
    }
  );

  try {
    // Voice: starting work
    await sendVoiceNotification(`Processing: ${msg.text.substring(0, 30)}`, "work");

    // Update workflow - OBSERVE phase starting
    workflowStore.addPhase(traceId, "OBSERVE", "in_progress");

    // Call PAI with trace context
    const result = await callPAI(msg.text, msg.userId, msg.traceContext);

    // Validate PAI response for completeness before processing
    const validationResult = validatePAIResponse(result.response);
    if (!validationResult.isValid) {
      console.warn(`‚ö†Ô∏è PAI response validation failed: ${validationResult.reason}`);
      console.warn(`‚ö†Ô∏è Response length: ${result.response.length}`);
      console.warn(`‚ö†Ô∏è Response preview: ${result.response.substring(0, 100)}...`);

      // Send error notification about truncated response
      await sendVoiceNotification(
        `PAI response incomplete: ${validationResult.reason}`,
        "error"
      );

      // Update workflow with validation failure
      processSpan.setAttribute("pai.response.validation.failed", true);
      processSpan.setAttribute("pai.response.validation.reason", validationResult.reason);
      tracer.span.error(processSpan, new Error(`Response validation failed: ${validationResult.reason}`));

      // Try to send error message instead
      const errorMessage = `‚ùå I received an incomplete response from PAI. This might be due to network issues or server load. Please try asking your question again.`;
      await bot.api.sendMessage(parseInt(ALLOWED_USER_ID), errorMessage);

      // Mark workflow as failed
      workflowStore.failExecution(traceId, `Response validation failed: ${validationResult.reason}`);

      // Clean up and return
      processSpan.end();
      isProcessing = false;
      tracker.releaseLock();
      return;
    }

    // Log successful validation
    console.log(`‚úÖ PAI response validation passed (${result.response.length} characters)`);
    processSpan.setAttribute("pai.response.validation.passed", true);
    processSpan.setAttribute("pai.response.length", result.response.length);

    // Update workflow - OBSERVE complete, THINK through LEARN phases
    workflowStore.completePhase(traceId, "OBSERVE");
    workflowStore.completePhase(traceId, "THINK");
    workflowStore.completePhase(traceId, "PLAN");
    workflowStore.completePhase(traceId, "BUILD");
    workflowStore.completePhase(traceId, "EXECUTE");
    workflowStore.completePhase(traceId, "VERIFY");
    workflowStore.completePhase(traceId, "LEARN");

    // Add subagent tracking to span
    if (result.phases) {
      result.phases.forEach(phase => {
        processSpan.setAttribute(`pai.phase.${phase.name}.duration`, phase.duration);
        if (phase.subagents) {
          processSpan.setAttribute(`pai.phase.${phase.name}.subagents`, phase.subagents.join(","));
        }
      });
    }

    // Process response through anti-repetition system
    const messageId = `response-${Date.now()}-${msg.userId}`;
    const { finalResponse: processedResponse, wasModified, similarity } = antiRepetitionSystem.processResponse(
      result.response,
      msg.userId,
      messageId
    );

    // Log repetition detection
    if (wasModified) {
      console.log(`üîÑ Response modified due to repetition (similarity: ${Math.round(similarity * 100)}%)`);
      processSpan.setAttribute("anti.repetition.detected", true);
      processSpan.setAttribute("anti.repetition.similarity", similarity);
      processSpan.setAttribute("anti.response.modified", true);
    } else {
      processSpan.setAttribute("anti.repetition.detected", false);
    }

    // Send response via Telegram with delivery verification
    const chatId = parseInt(ALLOWED_USER_ID);
    const deliveryResult = await verifyMessageDelivery(
      chatId,
      `ü§ñ PAI Response:\n\n${processedResponse}`,
      msg.userId
    );

    if (!deliveryResult.success) {
      console.error("‚ùå Main response delivery failed:", deliveryResult.error);
      // Try to send error notification
      try {
        await sendVoiceNotification(
          `Failed to deliver response to user ${msg.userId}`,
          "error"
        );
      } catch (voiceError) {
        console.error("‚ùå Voice notification also failed:", voiceError);
      }
    } else {
      processSpan.setAttribute("telegram.response.delivered", true);
      processSpan.setAttribute("telegram.message.id", deliveryResult.messageId);
    }

    processSpan.setAttribute("telegram.response.sent", true);
    tracer.span.success(processSpan);

    // ========================================================================
    // OBSERVABILITY: Complete workflow and add PAI response to lineage
    // ========================================================================
    workflowStore.completeExecution(traceId, result.response, result.sessionId);

    lineageStore.addPAIResponse(
      `pai-${msg.id}`,
      result.response,
      msg.userId,
      msg.id,
      traceId,
      {
        sessionId: result.sessionId,
        responseLength: result.response.length,
      }
    );

    if (result.sessionId) {
      lineageStore.updateSessionId(msg.id, result.sessionId);
    }

    // Voice: complete
    await sendVoiceNotification("Response delivered", "complete");

    console.log("‚úÖ Message processed");
  } catch (error) {
    console.error("‚ùå Processing error:", error);
    tracer.span.error(processSpan, error as Error);

    // ========================================================================
    // OBSERVABILITY: Mark workflow as failed
    // ========================================================================
    workflowStore.failExecution(traceId, (error as Error).message);

    // Send error message with delivery verification
    const errorResult = await verifyMessageDelivery(
      parseInt(ALLOWED_USER_ID),
      `‚ùå Error processing message: ${error instanceof Error ? error.message : String(error)}`,
      msg.userId,
      2 // Fewer retries for error messages
    );

    if (!errorResult.success) {
      console.error("‚ùå Error message delivery failed:", errorResult.error);
      // Try voice notification as fallback
      try {
        await sendVoiceNotification(
          `Critical: Cannot deliver error message to user ${msg.userId}`,
          "error"
        );
      } catch (voiceError) {
        console.error("‚ùå Voice fallback also failed:", voiceError);
      }
    }
    await sendVoiceNotification("Processing failed", "error");
  } finally {
    processSpan.end();
    isProcessing = false;

    // ========================================================================
    // OBSERVABILITY: Release instance lock
    // ========================================================================
    tracker.releaseLock();
  }
}

// Check for new messages flag
async function checkNewMessageFlag(): Promise<boolean> {
  try {
    const exists = await Bun.file(NEW_MESSAGE_FLAG).exists();
    if (exists) {
      unlinkSync(NEW_MESSAGE_FLAG);
      return true;
    }
  } catch {
    // Ignore
  }
  return false;
}

// Main processing loop
async function mainLoop() {
  // Check if communication agent flagged new message
  const hasFlag = await checkNewMessageFlag();

  if (hasFlag) {
    console.log("üö© New message flag detected");
    await processMessageQueue();
  }

  // Continue monitoring
  setTimeout(mainLoop, 500); // Check every 500ms
}

// Status endpoint for monitoring
bot.command("status", async (ctx) => {
  const uptime = process.uptime();

  try {
    const queueData = await Bun.readableStreamToText(Bun.file(MESSAGE_QUEUE_PATH).stream());
    const queue = JSON.parse(queueData) || [];
    const queued = queue.length;

    // Get anti-repetition stats
    const antiStats = antiRepetitionSystem.getBufferStats();

    await ctx.reply(`
üìä PAI Main Bot Status
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üü¢ Status: Online & Processing
‚è±Ô∏è Uptime: ${Math.floor(uptime / 60)}m ${Math.floor(uptime % 60)}s
üì¨ Queued: ${queued} messages
üíæ Sessions: ${sessions.size}
üîÑ Processing: ${isProcessing ? "Active" : "Idle"}

ü§ñ Communication Agent: Running
üîä Voice Agent: Running

üõ°Ô∏è Anti-Repetition System:
   Buffer: ${antiStats.size}/${antiRepetitionSystem.constructor.prototype.BUFFER_SIZE} responses
   Active Users: ${Object.keys(antiStats.userCounts).length}

‚ú® Full system operational!
    `.trim());
  } catch (error) {
    await ctx.reply("Status check failed");
  }
});

// Debug endpoint for delivery issues
bot.command("delivery-debug", async (ctx) => {
  const userId = ctx.from.id.toString();

  try {
    const metrics = deliveryMetrics.get(userId);
    const consecutive = consecutiveFailures.get(userId) || 0;

    if (metrics) {
      await ctx.reply(`
üîç Delivery Debug for User ${userId}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìä Total Attempts: ${metrics.totalAttempts}
‚úÖ Successful: ${metrics.successfulDeliveries}
‚ùå Failed: ${metrics.failedDeliveries}
üìà Success Rate: ${metrics.totalAttempts > 0 ? (metrics.successfulDeliveries / metrics.totalAttempts * 100).toFixed(1) : '0'}%

üîÑ Consecutive Failures: ${consecutive}

${metrics.lastFailure ? `üïí Last Failure: ${metrics.lastFailure.toISOString()}` : '‚úÖ No failures recorded'}
${metrics.lastSuccess ? `‚úÖ Last Success: ${metrics.lastSuccess.toISOString()}` : '‚è≥ No successful deliveries'}
      `);
    } else {
      await ctx.reply("No delivery data found for this user.");
    }
  } catch (error) {
    await ctx.reply("Debug check failed");
  }
});

// Start
console.log("üöÄ PAI Telegram Bot Starting...");
await loadSessions();

// Clear any stale messages from previous runs (fresh start)
await Bun.write(MESSAGE_QUEUE_PATH, "[]");
console.log("üßπ Queue cleared - ready for fresh messages");

// Start monitoring loop
console.log("üîÑ Starting monitoring loop...");
mainLoop();

console.log("‚úÖ Main bot ready! Monitoring message queue...");

// Keep process alive with periodic heartbeat
setInterval(() => {
  // Heartbeat - just to keep process alive
  const now = new Date();
  if (now.getSeconds() === 0) {
    console.log(`üíì Main bot alive at ${now.toISOString()}`);
  }
}, 60000); // Every minute
await sendVoiceNotification("PAI Telegram system fully online", "complete");

// Keep process alive
process.on("SIGINT", () => {
  console.log("\nüõë Main bot shutting down...");
  bot.stop();
  process.exit(0);
});
